\section{Implementation}

\if 0
\begin{comment}
	\emph{EE:}
	We've two implementations.
	(implementation strategy) having two codebases using two different languages: - confidence that each implementation was correct - ability to work concurrently and with individual time constraints.
	cons: increased debuging time: Debug both in isolation, then debug their communication.
	We overshot (debugging in isolation is our current status). took much time to debug what was going wrong and we ended up with two buggy codebases. (The ML code is complete. The C code is incomplete. Both have bugs in isolation. We've yet to reach integration bugs.)
	
	!!!Things are broken!!!
\end{comment}
\fi

This section describes our implementation of the DAA protocol on the IBM 4764
PCI-X Cryptographic Coprocessor. Our implementation strategy is to have (1) a
full implementation, i.e., prover and verifier, in a functional programming
language, and (2) a separate implementation for the prover in a language that
compiles into an executable the secure cryptocard understands.

The implementation in a functional programming language makes it easier to
scrutinize the code to find any mismatch between the protocol specifications and
the associated implementation. It is also a step closer to formalizing the
protocol into a list of specifications that we can formally reason about its
correctness though a theorem prover. We chose ML to be our functional
programming language. Given the tools provided in the IBM Developers' Toolkit,
we can compile a separate implementation of the prover in C code into a binary
that can be deployed into the secure cryptoprocessor.

The two separate codebases give us the ability to progress independently and
have a strong measure of correctness that both implementations are correct when
having two isolated codebases communicating with each other.

{\bf Status:}
The ML code is complete, however, there is a problem verifying the parameters
generated by the issuer. We still need to debug few problems that appear due to
mismatch of the generated hash values. Next, we integrate the prover and
verifier and debug issues as they appear.

The cryptocard-side code, prover in C, is almost complete. We use the GMP
library to perform big integer operations that are not supported by the
cryptocard, e.g., linear arithmetic. However, some functionalities that are
implemented now as utility functions need to be reimplemented to use the exposed
functionality of the secure cryptocard.